//@ts-check

//Start the frame buffer multi dimensional array
let frameBufferArr = `<pre>
/**Auto generated by Monochromer. Don't edit by hand**/

//CONDITIONAL COMPILATION DEFINITIONS
#define RESOLUTION_640x480
#define PALETTE_1BIT

const unsigned short hPixels = 640; //Number of horizontal pixels in the targeted VGA mode
const unsigned short vPixels = 480; //Number of vertical pixels in the targeted VGA mode
const unsigned char cols = 24; //Number of columns/bytes horizontally supported by the current display mode
const unsigned char rows = 240; //Number of rows vertically supported by the current display mode

//NOTE: The following frame buffer maps directly to the frame buffer displayed
const unsigned char frameBuffer[rows][cols] PROGMEM = {\n`;

function init() {
    //Add onload to img
    canvas = document.querySelector("canvas");
    ctx = canvas.getContext("2d");
    img.addEventListener("load", () => {
        const imgScaledWidth = (img.width*canvas.height)/img.height;
        ctx.drawImage(img, (canvas.width-imgScaledWidth*0.7)/2, 0, imgScaledWidth*0.7, canvas.height);
    });

    //Add onclick to monochromize button
    buttonContainer.children[1].addEventListener("click", () => {
        const frameBuffer = ctx.getImageData(0, 0, canvas.width, canvas.height);

        //Calculate a better mid point
        //NOTE: midpoint = (sum of pixelRGBAverage)/pixelCount
        let rgbAverageSum = 0;
        for (let pixel = 0; pixel < frameBuffer.data.length; pixel+=4) {
            const rgbAverage = (frameBuffer.data[pixel] + frameBuffer.data[pixel+1] + frameBuffer.data[pixel+2])/3;
            rgbAverageSum += rgbAverage;
        }
        const midPoint = rgbAverageSum/(frameBuffer.data.length/4);

        //Determine the black/white-ness based on mid point for each pixel
        for (let pixel = 0; pixel < frameBuffer.data.length; pixel+=4) {
            const rgbAverage = (frameBuffer.data[pixel] + frameBuffer.data[pixel+1] + frameBuffer.data[pixel+2])/3;
            if (rgbAverage > midPoint) {
                frameBuffer.data[pixel] = 255;
                frameBuffer.data[pixel + 1] = 255;
                frameBuffer.data[pixel + 2] = 255;
            } else {
                frameBuffer.data[pixel] = 0;
                frameBuffer.data[pixel + 1] = 0;
                frameBuffer.data[pixel + 2] = 0;
            }
            frameBuffer.data[pixel + 3] = 255; //No transparency
        }
        ctx.putImageData(frameBuffer, 0, 0); //Update canvas
    });

    //Add onclick to export button
    buttonContainer.children[2].addEventListener("click", () => {
        const frameBuffer = ctx.getImageData(0, 0, canvas.width, canvas.height);

        for (let row = 0; row < frameBuffer.height; row++) {
            let rowArr = "    {"; //Start a new array for current row

            for (let col = 0; col < frameBuffer.width; col+=8) {
                let arrElementBin = ""; //Start a new 8bit binary string for current column

                for (let bit = col; bit < col+8; bit++) {
                    //Calculate Channel0=R index for current pixel
                    const r = row * (frameBuffer.width * 4) + bit * 4;

                    if (bit === 191) {
                        //CASE: Currently processing the last bit of the line
                        //Make that bit high. No matter the actual value
                        arrElementBin += "1";
                    } else {
                        //CASE: Currently processing a bit other than the last bit
                        //NOTE: By now every R,G,B byte of the current pixel is either 255 or 0
                        //NOTE: So checking only the R byte is enough
                        if (frameBuffer.data[r] === 0) {
                            arrElementBin += "0";
                        } else if (frameBuffer.data[r] === 255) {
                            arrElementBin += "1";
                        }
                    }
                }
                
                const arrElementHex = parseInt(arrElementBin, 2).toString(16).toUpperCase(); //Parse the binary string as hex with uppercase
                rowArr += "0x" + (arrElementHex.length == 1 ? "0" + arrElementHex : arrElementHex) + ","; //Make the hex always 2 digit //Insert the hex byte as the next element in the rowStr array
            }

            frameBufferArr += rowArr.slice(0, -1) + "},\n"; //Remove the trailing comma in the last element //close the array
        }

        frameBufferArr = frameBufferArr.slice(0, -2) + "\n};</pre>"; //Remove the trailing comma in the last array //Close the multi dimensional array

        const newWindow = window.open("", fileInput.files[0].name);
        newWindow.document.body.innerHTML = frameBufferArr;
    });
}