class Monochromer {
    static lastObjectURL: string | null;

    static midPointInput: HTMLInputElement;
    static buttonContainer: HTMLDivElement;
    static fileInput: HTMLInputElement;
    static img: HTMLImageElement;
    static canvas: HTMLCanvasElement;
    static ctx: CanvasRenderingContext2D;

    static {
        this.midPointInput = document.getElementById("midPointInput") as HTMLInputElement;
        this.buttonContainer = document.getElementById("buttonContainer") as HTMLDivElement;
        this.fileInput = this.buttonContainer.children[0].firstElementChild as HTMLInputElement;
        this.img = this.buttonContainer.children[0].children[1] as HTMLImageElement;
        this.canvas = document.querySelector("canvas") as HTMLCanvasElement;
        this.ctx = this.canvas.getContext("2d") as CanvasRenderingContext2D;
    }

    static init() {
        //Clear canvas
        this.ctx.fillStyle = "black";
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        //Add onclick to upload file button
        this.buttonContainer.children[0].addEventListener("click", () => this.fileInput.click());

        //Add onload to img
        this.img.addEventListener("load", () => {
            this.loadImageOnCanvas();

            //Auto calculate a suitable mid point
            //NOTE: midpoint = (sum of pixelRGBAverage)/pixelCount

            const frameBuffer = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
            let rgbAverageSum = 0;
            for (let pixel = 0; pixel < frameBuffer.data.length; pixel += 4) {
                const rgbAverage = (frameBuffer.data[pixel] + frameBuffer.data[pixel + 1] + frameBuffer.data[pixel + 2]) / 3;
                rgbAverageSum += rgbAverage;
            }

            this.midPointInput.value = (rgbAverageSum / (frameBuffer.data.length / 4)).toString();

            //Immediately preview effects
            this.applyEffects();
        });

        //Add onchange to upload file input
        this.fileInput.addEventListener("change", () => this.changeUploadedImage());

        //Add onchange to midpoint input
        this.midPointInput.addEventListener("change", () => {
            this.loadImageOnCanvas();
            this.applyEffects();
        });

        //Add onclick to export button
        this.buttonContainer.children[2].addEventListener("click", () => this.generateCode());
    }

    static loadImageOnCanvas() {
        //Clear canvas
        this.ctx.fillStyle = "black";
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        const imgScaledWidth = (this.img.width * this.canvas.height) / this.img.height;
        this.ctx.drawImage(this.img, (this.canvas.width - imgScaledWidth * 0.7) / 2, 0, imgScaledWidth * 0.7, this.canvas.height);
    }

    static changeUploadedImage() {
        if (this.fileInput.files) {
            if (this.lastObjectURL) {
                URL.revokeObjectURL(this.lastObjectURL);
            }
            this.lastObjectURL = URL.createObjectURL(this.fileInput.files[0]);
            this.img.src = this.lastObjectURL as string;
        }
    }

    static applyEffects() {
        const frameBuffer = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);

        //Determine the black/white-ness based on mid point for each pixel
        for (let pixel = 0; pixel < frameBuffer.data.length; pixel += 4) {
            const rgbAverage = (frameBuffer.data[pixel] + frameBuffer.data[pixel + 1] + frameBuffer.data[pixel + 2]) / 3;
            if (rgbAverage > parseInt(this.midPointInput.value)) {
                frameBuffer.data[pixel] = 255;
                frameBuffer.data[pixel + 1] = 255;
                frameBuffer.data[pixel + 2] = 255;
            } else {
                frameBuffer.data[pixel] = 0;
                frameBuffer.data[pixel + 1] = 0;
                frameBuffer.data[pixel + 2] = 0;
            }
            frameBuffer.data[pixel + 3] = 255; //No transparency
        }
        this.ctx.putImageData(frameBuffer, 0, 0); //Update canvas
    }

    static generateCode() {
        //Initial parts of the code
        let frameBufferArr = 
`<pre>
/**Auto generated by Monochromer. No to be edited by hand**/

//CONDITIONAL COMPILATION DEFINITIONS
#define RESOLUTION_640x480
#define PALETTE_1BIT

const unsigned short hPixels = 640; //Number of horizontal pixels in the targeted VGA mode
const unsigned short vPixels = 480; //Number of vertical pixels in the targeted VGA mode
const unsigned char cols = ${this.canvas.width/8}; //Number of columns/bytes horizontally supported by the current display mode
const unsigned char rows = ${this.canvas.height}; //Number of rows vertically supported by the current display mode

//NOTE: The following frame buffer maps directly to the frame buffer displayed
const unsigned char frameBuffer[rows][cols] PROGMEM = {\n`;

        const frameBuffer = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);

        for (let row = 0; row < frameBuffer.height; row++) {
            let rowArr = "    {"; //Start a new array for current row

            for (let col = 0; col < frameBuffer.width; col += 8) {
                let arrElementBin = ""; //Start a new 8bit binary string for current column

                for (let bit = col; bit < col + 8; bit++) {
                    //Calculate Channel0=R index for current pixel
                    const r = row * (frameBuffer.width * 4) + bit * 4;

                    if (bit === 191) {
                        //CASE: Currently processing the last bit of the line
                        //NOTE: In USART based code, ther will be a 1 pixel wide HIGH band in the left side of the frame. To balance that ugliness, we manually add a 1 pixel wide HIGH band at the end also.
                        //Make that bit high. No matter the actual value
                        arrElementBin += "1";
                    } else {
                        //CASE: Currently processing a bit other than the last bit
                        //NOTE: By now every R,G,B byte of the current pixel is either 255 or 0
                        //NOTE: So checking only the R byte is enough
                        if (frameBuffer.data[r] === 0) {
                            arrElementBin += "0";
                        } else if (frameBuffer.data[r] === 255) {
                            arrElementBin += "1";
                        }
                    }
                }

                const arrElementHex = parseInt(arrElementBin, 2).toString(16).toUpperCase(); //Parse the binary string as hex with uppercase
                rowArr += "0x" + (arrElementHex.length == 1 ? "0" + arrElementHex : arrElementHex) + ","; //Make the hex always 2 digit //Insert the hex byte as the next element in the rowStr array
            }

            frameBufferArr += rowArr.slice(0, -1) + "},\n"; //Remove the trailing comma in the last element //close the array
        }

        frameBufferArr = frameBufferArr.slice(0, -2) + "\n};</pre>"; //Remove the trailing comma in the last array //Close the multi dimensional array

        const newWindow = window.open() as Window;
        newWindow.document.body.innerHTML = frameBufferArr;
    }
}

Monochromer.init();